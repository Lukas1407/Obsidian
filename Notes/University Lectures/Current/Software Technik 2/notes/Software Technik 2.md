## Something we know after 50 years of software development
- Putting more people on a late project makes it later
- Errors are more frequent during design & requirement phase
	- -> And more difficult to fix
- Testing can only show the presence of errors but not their absence
- A system that is used will be changed
- Only what is hidden can be changed without risk
## Content
- [[Clean Code]]
- [[Command-Query Separation (CQS)]]
- [[Software Architecture]]
- [[Requirement Engineering]]
- [[Palladio Component Model (PCM)]]
- [[4+1 Architectural Views Model]]
- [[Unified Process (UP)]]
- [[Architectural Patterns]]
- [[Architectural Styles]]
- [[Layered Architecture]]
- [[Domain Layer vs. Domain Model]]
- [[Object-Oriented Analysis (OOA)]]
- [[Object-Oriented Design (OOD)]]
- [[Model-View-Controller (MVC)]]
- [[Data Transfer Objects (DTOs)]]
- [[Architecture Example Point of Sale (PoS)]]
- [[Observer Pattern]]
- [[Behavior vs Maintainability]]
- [[Clean Architecture]]
- [[Depend in the Direction of Stability]]
- [[Cyclic Dependencies]]
- [[Decoupling Modes]]
- [[Software Components]]
- [[Component Model]]
- [[OSGi (Open Service Gateway Initiative)]]
- [[Web Services]]
- [[Service-Oriented Architecture (SOA)]]
- [[Core Web Service Technologies]]
- [[Component Jigsaw Puzzle]]
- [[Composite Component]]
- [[Microservice]]
- [[Enterprise Application]]
- [[Integrating OO Programming with Relational Database Management System (RDBMS)]]
- [[Java Persistence API]]
- [[Cloud Computing]]
- [[Single-Tenant Architecture]]
- [[Multi-Tenant Architecture]]
- [[Partitioning of Resources]]
- [[Virtualization]]
- [[Containerization]]
- [[TCO of License-based Software Delivery]]
- [[Grep The Web]]
- [[Simple Controller Architecture for Resilience]]
- [[MapReduce]]
- [[Domain-Driven Design (DDD)]]
- [[Model-Driven Design (MDD)]]
- [[Domain-Driven Design Building Blocks]]
- [[Domain-Driven Design Strategic Design]]
- [[Software Development Processes]]
- [[Software Process Model]]
- [[Reviews]]
- [[Code Reading Techniques]]
- [[Psychological Interaction Patterns]]
- [[Requirements Engineering]]
- [[Software Requirements Specification (SRS)]]
- [[Writing Recommendations for Requirements]]
- [[Requirements Validation]]
- [[Requirements Prioritization]]
- [[Model-based Requirements Elicitation]]
- [[Shaping Heuristics]]
- [[Use Case Diagrams (UCD)]]
- [[Software Quality]]
- [[Real-time Systems]]
- [[Stimulus-Response Systems]]
- [[Interrupts vs. Periodic Processes]]
- [[Monitoring & Control Systems]]
- [[Data Acquisition Systems]]
- [[Actuator Systems]]
- [[Safety & Reliability]]
- [[Fault-Error-Failure Chain]]
- [[Real-Time Patterns]]
- [[Safety & Reliability Pattern]]
- [[Software Security]]
- [[Principles for Building Secure Software]]
- [[Cryptography]]
- [[Ethos and Ethics in Software Engineering]]

## Learning Goals
### Software Architecture: Be able to 
- reproduce and describe the definitions of software architecture 
- explain Conway‘s Law 
- explain the difference between software architecture and software architecture documentation 
- describe the advantages of explicit architecture and the influences on architecture decisions 
- assign design decisions and elements to architectural layers 
- explain the architectural style layered architecture 
- apply the patterns Model View Controller and Observer to examples 
### Clean Architecture: Be able to 
- know underlying principles of clean architecture styles 
- know ”circles” of the clean architecture style and how they are applied 
- apply dependency inversion to resolve violations to the clean architecture
### Enterprise Application Architecture: Be able to –
- characterize enterprise systems and decide which characteristics a given application has 
- describe patterns of structuring domain logic, data source architectural patterns, and object-relational structural patterns. 
- select an appropriate pattern for a given design problem and justify its selection with respect to its advantages and disadvantages 
- apply a selected enterprise application pattern for a concrete design
### Software Components: Be able to –
- understand and define component models 
- Read and “write” component diagrams using the UML notation 
- describe the elements of the Palladio component model (PCM) 
- explain some of the design decisions made in the PCM 
- know the influence factors for the performance of software components
### Domain-Driven Design: Be able to –
- know ideas and patterns underlying Domain-Driven Design 
- Identify bounded context, context map and interaction pattern for a given use case and scenario description 
- distinguish and assign different building blocks to domain model 
- specify additional support patterns to an existing domain model 
- Distinguish different strategic designs
### Microservices: Be able to – 
- explain why Microservice is an architectural style. 
- know the characteristics of Microservices 
- explain the typical elements of a Microservice
### Cloud Computing and Cloud Architecture: Be able to –
- know the differences between cloud computing and hosted resources regarding used technologies, software delivery model 
- explain the economics of cloud computing
- know and apply the map-reduce programming model 
- know and apply architectural principles of cloud software 
- distinguish SaaS, PaaS, and IaaS and give examples for each
### Software Development Processes: Be able to – 
- recognize and distinguish different types of process models 
- understand the evolutionary and incremental development 
- describe the advantage of incremental over a sequential process 
- describe the phases and disciplines of the Unified Process 
### Agile Development: Be able to – 
- know agile development ideas and principles 
- understand how to perform a project following an eXtreme Programming or Scrum process 
- distinguish Unified Process, eXtreme Programming, and Scrum process
- discuss advantages and disadvantages of agile practices
### Requirements Engineering: Be able to – 
- describe the terms and activities of Requirements Engineering 
- classify and assess requirements according to the facets kind and representation. 
- apply fundamental guidelines on specifying natural language requirements 
### Use Cases: Be able to –
- describe the purpose and the elements of use case diagrams 
- classify use cases according to their level and goal 
- create use case diagrams and ”fully-dressed” use cases 
- describe their role in the software development process
### Software Quality – Reliability: Be able to – 
- know and distinguish different kinds of software qualities 
- explain the concept of a real-time system 
- distinguish between different types of real-time systems 
	- Hard and soft real-time systems, vs. monitoring and control systems 
- select a suitable safety and reliability pattern for a given system 
### Software Quality – Security: Be able to –
- know fundamental ideas and challenges of software security 
- recognize common security problems and know means to avoid them
## Which Diagrams Should I Know? 
- Use Case diagrams 
- Class diagrams 
- Sequence Diagrams 
- Deployment Diagrams 
- Activity Diagrams 
- Component diagrams 
- Know the basic constructs and notation used in the slides (UML 2.5 Notation)
